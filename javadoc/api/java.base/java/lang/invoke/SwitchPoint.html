<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) -->
<title>SwitchPoint (Java SE 17 &amp; JDK 17 [build 5])</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: module: java.base, package: java.lang.invoke, class: SwitchPoint">
<meta name="generator" content="javadoc/ClassWriterImpl">
<meta name="keywords" content="java.lang.invoke.SwitchPoint class">
<meta name="keywords" content="hasBeenInvalidated()">
<meta name="keywords" content="guardWithTest()">
<meta name="keywords" content="invalidateAll()">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header"><div style="padding: 6px; text-align: center; font-size: 80%; font-family: DejaVu Sans, Arial, Helvetica, sans-serif; font-weight: normal;">This specification is not final and is subject to change. Use is subject to <a href="https://www.oracle.com/java/javase/terms/license/java17speclicense.html">license terms</a>.</div>
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<div class="about-language"><div style="margin-top: 9px;"><strong>Java SE 17 &amp; JDK 17</strong> <br><strong>DRAFT 17-crac+5-19</strong></div></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="../../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/SwitchPoint.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../preview-list.html">Preview</a></li>
<li><a href="../../../../new-list.html">New</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html#class">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" value="search" disabled="disabled">
<input type="reset" id="reset-button" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="module-label-in-type">Module</span>&nbsp;<a href="../../../module-summary.html">java.base</a></div>
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">java.lang.invoke</a></div>
<h1 title="Class SwitchPoint" class="title">Class SwitchPoint</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="../Object.html" title="class in java.lang">java.lang.Object</a>
<div class="inheritance">java.lang.invoke.SwitchPoint</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">SwitchPoint</span>
<span class="extends-implements">extends <a href="../Object.html" title="class in java.lang">Object</a></span></div>
<div class="block"><p>
 A <code>SwitchPoint</code> is an object which can publish state transitions to other threads.
 A switch point is initially in the <em>valid</em> state, but may at any time be
 changed to the <em>invalid</em> state.  Invalidation cannot be reversed.
 A switch point can combine a <em>guarded pair</em> of method handles into a
 <em>guarded delegator</em>.
 The guarded delegator is a method handle which delegates to one of the old method handles.
 The state of the switch point determines which of the two gets the delegation.
 <p>
 A single switch point may be used to control any number of method handles.
 (Indirectly, therefore, it can control any number of call sites.)
 This is done by using the single switch point as a factory for combining
 any number of guarded method handle pairs into guarded delegators.
 <p>
 When a guarded delegator is created from a guarded pair, the pair
 is wrapped in a new method handle <code>M</code>,
 which is permanently associated with the switch point that created it.
 Each pair consists of a target <code>T</code> and a fallback <code>F</code>.
 While the switch point is valid, invocations to <code>M</code> are delegated to <code>T</code>.
 After it is invalidated, invocations are delegated to <code>F</code>.
 <p>
 Invalidation is global and immediate, as if the switch point contained a
 volatile boolean variable consulted on every call to <code>M</code>.
 The invalidation is also permanent, which means the switch point
 can change state only once.
 The switch point will always delegate to <code>F</code> after being invalidated.
 At that point <code>guardWithTest</code> may ignore <code>T</code> and return <code>F</code>.
 <p>
 Here is an example of a switch point in action:
 <pre><code>
 MethodHandle MH_strcat = MethodHandles.lookup()
     .findVirtual(String.class, "concat", MethodType.methodType(String.class, String.class));
 SwitchPoint spt = new SwitchPoint();
 assert(!spt.hasBeenInvalidated());
 // the following steps may be repeated to re-use the same switch point:
 MethodHandle worker1 = MH_strcat;
 MethodHandle worker2 = MethodHandles.permuteArguments(MH_strcat, MH_strcat.type(), 1, 0);
 MethodHandle worker = spt.guardWithTest(worker1, worker2);
 assertEquals("method", (String) worker.invokeExact("met", "hod"));
 SwitchPoint.invalidateAll(new SwitchPoint[]{ spt });
 assert(spt.hasBeenInvalidated());
 assertEquals("hodmet", (String) worker.invokeExact("met", "hod"));
 </code></pre>
 <p style="font-size:smaller;">
 <em>Discussion:</em>
 Switch points are useful without subclassing.  They may also be subclassed.
 This may be useful in order to associate application-specific invalidation logic
 with the switch point.
 Notice that there is no permanent association between a switch point and
 the method handles it produces and consumes.
 The garbage collector may collect method handles produced or consumed
 by a switch point independently of the lifetime of the switch point itself.
 <p style="font-size:smaller;">
 <em>Implementation Note:</em>
 A switch point behaves as if implemented on top of <a href="MutableCallSite.html" title="class in java.lang.invoke"><code>MutableCallSite</code></a>,
 approximately as follows:
 <pre><code>
 public class SwitchPoint {
     private static final MethodHandle
         K_true  = MethodHandles.constant(boolean.class, true),
         K_false = MethodHandles.constant(boolean.class, false);
     private final MutableCallSite mcs;
     private final MethodHandle mcsInvoker;
     public SwitchPoint() {
         this.mcs = new MutableCallSite(K_true);
         this.mcsInvoker = mcs.dynamicInvoker();
     }
     public MethodHandle guardWithTest(
             MethodHandle target, MethodHandle fallback) {
         // Note:  mcsInvoker is of type ()boolean.
         // Target and fallback may take any arguments, but must have the same type.
         return MethodHandles.guardWithTest(this.mcsInvoker, target, fallback);
     }
     public static void invalidateAll(SwitchPoint[] spts) {
         List&lt;MutableCallSite&gt; mcss = new ArrayList&lt;&gt;();
         for (SwitchPoint spt : spts)  mcss.add(spt.mcs);
         for (MutableCallSite mcs : mcss)  mcs.setTarget(K_false);
         MutableCallSite.syncAll(mcss.toArray(new MutableCallSite[0]));
     }
 }
 </code></pre></div>
<dl class="notes">
<dt>Since:</dt>
<dd>1.7</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor-summary">
<h2>Constructor Summary</h2>
<div class="caption"><span>Constructors</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Constructor</div>
<div class="table-header col-last">Description</div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E()" class="member-name-link">SwitchPoint</a>()</code></div>
<div class="col-last even-row-color">
<div class="block">Creates a new switch point.</div>
</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#guardWithTest(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)" class="member-name-link">guardWithTest</a><wbr>(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
 <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;fallback)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Returns a method handle which always delegates either to the target or the fallback.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#hasBeenInvalidated()" class="member-name-link">hasBeenInvalidated</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Determines if this switch point has been invalidated yet.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#invalidateAll(java.lang.invoke.SwitchPoint%5B%5D)" class="member-name-link">invalidateAll</a><wbr>(<a href="SwitchPoint.html" title="class in java.lang.invoke">SwitchPoint</a>[]&nbsp;switchPoints)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Sets all of the given switch points into the invalid state.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods declared in class&nbsp;java.lang.<a href="../Object.html" title="class in java.lang">Object</a></h3>
<code><a href="../Object.html#clone()">clone</a>, <a href="../Object.html#equals(java.lang.Object)">equals</a>, <a href="../Object.html#finalize()">finalize</a>, <a href="../Object.html#getClass()">getClass</a>, <a href="../Object.html#hashCode()">hashCode</a>, <a href="../Object.html#notify()">notify</a>, <a href="../Object.html#notifyAll()">notifyAll</a>, <a href="../Object.html#toString()">toString</a>, <a href="../Object.html#wait()">wait</a>, <a href="../Object.html#wait(long)">wait</a>, <a href="../Object.html#wait(long,int)">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor-detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>SwitchPoint</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">SwitchPoint</span>()</div>
<div class="block">Creates a new switch point.</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="hasBeenInvalidated()">
<h3>hasBeenInvalidated</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">hasBeenInvalidated</span>()</div>
<div class="block">Determines if this switch point has been invalidated yet.

 <p style="font-size:smaller;">
 <em>Discussion:</em>
 Because of the one-way nature of invalidation, once a switch point begins
 to return true for <code>hasBeenInvalidated</code>,
 it will always do so in the future.
 On the other hand, a valid switch point visible to other threads may
 be invalidated at any moment, due to a request by another thread.
 <p style="font-size:smaller;">
 Since invalidation is a global and immediate operation,
 the execution of this query, on a valid switchpoint,
 must be internally sequenced with any
 other threads that could cause invalidation.
 This query may therefore be expensive.
 The recommended way to build a boolean-valued method handle
 which queries the invalidation state of a switch point <code>s</code> is
 to call <code>s.guardWithTest</code> on
 <a href="MethodHandles.html#constant(java.lang.Class,java.lang.Object)"><code>constant</code></a> true and false method handles.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>true if this switch point has been invalidated</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="guardWithTest(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)">
<h3>guardWithTest</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></span>&nbsp;<span class="element-name">guardWithTest</span><wbr><span class="parameters">(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
 <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;fallback)</span></div>
<div class="block">Returns a method handle which always delegates either to the target or the fallback.
 The method handle will delegate to the target exactly as long as the switch point is valid.
 After that, it will permanently delegate to the fallback.
 <p>
 The target and fallback must be of exactly the same method type,
 and the resulting combined method handle will also be of this type.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>target</code> - the method handle selected by the switch point as long as it is valid</dd>
<dd><code>fallback</code> - the method handle selected by the switch point after it is invalidated</dd>
<dt>Returns:</dt>
<dd>a combined method handle which always calls either the target or fallback</dd>
<dt>Throws:</dt>
<dd><code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - if either argument is null</dd>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the two method types do not match</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="MethodHandles.html#guardWithTest(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"><code>MethodHandles.guardWithTest(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="invalidateAll(java.lang.invoke.SwitchPoint[])">
<h3>invalidateAll</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">invalidateAll</span><wbr><span class="parameters">(<a href="SwitchPoint.html" title="class in java.lang.invoke">SwitchPoint</a>[]&nbsp;switchPoints)</span></div>
<div class="block">Sets all of the given switch points into the invalid state.
 After this call executes, no thread will observe any of the
 switch points to be in a valid state.
 <p>
 This operation is likely to be expensive and should be used sparingly.
 If possible, it should be buffered for batch processing on sets of switch points.
 <p>
 If <code>switchPoints</code> contains a null element,
 a <code>NullPointerException</code> will be raised.
 In this case, some non-null elements in the array may be
 processed before the method returns abnormally.
 Which elements these are (if any) is implementation-dependent.

 <p style="font-size:smaller;">
 <em>Discussion:</em>
 For performance reasons, <code>invalidateAll</code> is not a virtual method
 on a single switch point, but rather applies to a set of switch points.
 Some implementations may incur a large fixed overhead cost
 for processing one or more invalidation operations,
 but a small incremental cost for each additional invalidation.
 In any case, this operation is likely to be costly, since
 other threads may have to be somehow interrupted
 in order to make them notice the updated switch point state.
 However, it may be observed that a single call to invalidate
 several switch points has the same formal effect as many calls,
 each on just one of the switch points.

 <p style="font-size:smaller;">
 <em>Implementation Note:</em>
 Simple implementations of <code>SwitchPoint</code> may use
 a private <a href="MutableCallSite.html" title="class in java.lang.invoke"><code>MutableCallSite</code></a> to publish the state of a switch point.
 In such an implementation, the <code>invalidateAll</code> method can
 simply change the call site's target, and issue one call to
 <a href="MutableCallSite.html#syncAll(java.lang.invoke.MutableCallSite%5B%5D)">synchronize</a> all the
 private call sites.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>switchPoints</code> - an array of call sites to be synchronized</dd>
<dt>Throws:</dt>
<dd><code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - if the <code>switchPoints</code> array reference is null
                              or the array contains a null</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small><a href="https://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="https://docs.oracle.com/pls/topic/lookup?ctx=javase17&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples. <a href="https://docs.oracle.com/en/java/javase/index.html">Other versions.</a><br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../legal/copyright.html">Copyright</a> &copy; 1993, 2023, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="https://www.oracle.com/java/javase/terms/license/java17speclicense.html">license terms</a> and the <a href="https://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. <br><strong>DRAFT 17-crac+5-19</strong> <!-- Version 17-crac+5-19 --></small></p>
</footer>
</div>
</div>
</body>
</html>
