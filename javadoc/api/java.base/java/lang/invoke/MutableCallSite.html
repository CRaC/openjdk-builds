<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) -->
<title>MutableCallSite (Java SE 17 &amp; JDK 17 [build 6])</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: module: java.base, package: java.lang.invoke, class: MutableCallSite">
<meta name="generator" content="javadoc/ClassWriterImpl">
<meta name="keywords" content="java.lang.invoke.MutableCallSite class">
<meta name="keywords" content="getTarget()">
<meta name="keywords" content="setTarget()">
<meta name="keywords" content="dynamicInvoker()">
<meta name="keywords" content="syncAll()">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header"><div style="padding: 6px; text-align: center; font-size: 80%; font-family: DejaVu Sans, Arial, Helvetica, sans-serif; font-weight: normal;">This specification is not final and is subject to change. Use is subject to <a href="https://www.oracle.com/java/javase/terms/license/java17speclicense.html">license terms</a>.</div>
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<div class="about-language"><div style="margin-top: 9px;"><strong>Java SE 17 &amp; JDK 17</strong> <br><strong>DRAFT 17-crac+6-21</strong></div></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="../../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/MutableCallSite.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../preview-list.html">Preview</a></li>
<li><a href="../../../../new-list.html">New</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html#class">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" value="search" disabled="disabled">
<input type="reset" id="reset-button" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="module-label-in-type">Module</span>&nbsp;<a href="../../../module-summary.html">java.base</a></div>
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">java.lang.invoke</a></div>
<h1 title="Class MutableCallSite" class="title">Class MutableCallSite</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="../Object.html" title="class in java.lang">java.lang.Object</a>
<div class="inheritance"><a href="CallSite.html" title="class in java.lang.invoke">java.lang.invoke.CallSite</a>
<div class="inheritance">java.lang.invoke.MutableCallSite</div>
</div>
</div>
<section class="class-description" id="class-description">
<dl class="notes">
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="../../../../jdk.dynalink/jdk/dynalink/support/AbstractRelinkableCallSite.html" title="class in jdk.dynalink.support">AbstractRelinkableCallSite</a></code></dd>
</dl>
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">MutableCallSite</span>
<span class="extends-implements">extends <a href="CallSite.html" title="class in java.lang.invoke">CallSite</a></span></div>
<div class="block">A <code>MutableCallSite</code> is a <a href="CallSite.html" title="class in java.lang.invoke"><code>CallSite</code></a> whose target variable
 behaves like an ordinary field.
 An <code>invokedynamic</code> instruction linked to a <code>MutableCallSite</code> delegates
 all calls to the site's current target.
 The <a href="CallSite.html#dynamicInvoker()">dynamic invoker</a> of a mutable call site
 also delegates each call to the site's current target.
 <p>
 Here is an example of a mutable call site which introduces a
 state variable into a method handle chain.
 <!-- JavaDocExamplesTest.testMutableCallSite -->
 <blockquote><pre><code>
MutableCallSite name = new MutableCallSite(MethodType.methodType(String.class));
MethodHandle MH_name = name.dynamicInvoker();
MethodType MT_str1 = MethodType.methodType(String.class);
MethodHandle MH_upcase = MethodHandles.lookup()
    .findVirtual(String.class, "toUpperCase", MT_str1);
MethodHandle worker1 = MethodHandles.filterReturnValue(MH_name, MH_upcase);
name.setTarget(MethodHandles.constant(String.class, "Rocky"));
assertEquals("ROCKY", (String) worker1.invokeExact());
name.setTarget(MethodHandles.constant(String.class, "Fred"));
assertEquals("FRED", (String) worker1.invokeExact());
// (mutation can be continued indefinitely)
 </code></pre></blockquote>
 <p>
 The same call site may be used in several places at once.
 <blockquote><pre><code>
MethodType MT_str2 = MethodType.methodType(String.class, String.class);
MethodHandle MH_cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
MethodHandle MH_dear = MethodHandles.insertArguments(MH_cat, 1, ", dear?");
MethodHandle worker2 = MethodHandles.filterReturnValue(MH_name, MH_dear);
assertEquals("Fred, dear?", (String) worker2.invokeExact());
name.setTarget(MethodHandles.constant(String.class, "Wilma"));
assertEquals("WILMA", (String) worker1.invokeExact());
assertEquals("Wilma, dear?", (String) worker2.invokeExact());
 </code></pre></blockquote>
 <p>
 <em>Non-synchronization of target values:</em>
 A write to a mutable call site's target does not force other threads
 to become aware of the updated value.  Threads which do not perform
 suitable synchronization actions relative to the updated call site
 may cache the old target value and delay their use of the new target
 value indefinitely.
 (This is a normal consequence of the Java Memory Model as applied
 to object fields.)
 <p>
 The <a href="#syncAll(java.lang.invoke.MutableCallSite%5B%5D)"><code>syncAll</code></a> operation provides a way to force threads
 to accept a new target value, even if there is no other synchronization.
 <p>
 For target values which will be frequently updated, consider using
 a <a href="VolatileCallSite.html" title="class in java.lang.invoke">volatile call site</a> instead.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>1.7</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor-summary">
<h2>Constructor Summary</h2>
<div class="caption"><span>Constructors</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Constructor</div>
<div class="table-header col-last">Description</div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E(java.lang.invoke.MethodHandle)" class="member-name-link">MutableCallSite</a><wbr>(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target)</code></div>
<div class="col-last even-row-color">
<div class="block">Creates a call site object with an initial target method handle.</div>
</div>
<div class="col-constructor-name odd-row-color"><code><a href="#%3Cinit%3E(java.lang.invoke.MethodType)" class="member-name-link">MutableCallSite</a><wbr>(<a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code></div>
<div class="col-last odd-row-color">
<div class="block">Creates a blank call site object with the given method type.</div>
</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>final <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#dynamicInvoker()" class="member-name-link">dynamicInvoker</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Produces a method handle equivalent to an invokedynamic instruction
 which has been linked to this call site.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>final <a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#getTarget()" class="member-name-link">getTarget</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Returns the target method of the call site, which behaves
 like a normal field of the <code>MutableCallSite</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#setTarget(java.lang.invoke.MethodHandle)" class="member-name-link">setTarget</a><wbr>(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;newTarget)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Updates the target method of this call site, as a normal variable.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#syncAll(java.lang.invoke.MutableCallSite%5B%5D)" class="member-name-link">syncAll</a><wbr>(<a href="MutableCallSite.html" title="class in java.lang.invoke">MutableCallSite</a>[]&nbsp;sites)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Performs a synchronization operation on each call site in the given array,
 forcing all other threads to throw away any cached values previously
 loaded from the target of any of the call sites.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.invoke.CallSite">Methods declared in class&nbsp;java.lang.invoke.<a href="CallSite.html" title="class in java.lang.invoke">CallSite</a></h3>
<code><a href="CallSite.html#type()">type</a></code></div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods declared in class&nbsp;java.lang.<a href="../Object.html" title="class in java.lang">Object</a></h3>
<code><a href="../Object.html#clone()">clone</a>, <a href="../Object.html#equals(java.lang.Object)">equals</a>, <a href="../Object.html#finalize()">finalize</a>, <a href="../Object.html#getClass()">getClass</a>, <a href="../Object.html#hashCode()">hashCode</a>, <a href="../Object.html#notify()">notify</a>, <a href="../Object.html#notifyAll()">notifyAll</a>, <a href="../Object.html#toString()">toString</a>, <a href="../Object.html#wait()">wait</a>, <a href="../Object.html#wait(long)">wait</a>, <a href="../Object.html#wait(long,int)">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor-detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;(java.lang.invoke.MethodType)">
<h3>MutableCallSite</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">MutableCallSite</span><wbr><span class="parameters">(<a href="MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</span></div>
<div class="block">Creates a blank call site object with the given method type.
 The initial target is set to a method handle of the given type
 which will throw an <a href="../IllegalStateException.html" title="class in java.lang"><code>IllegalStateException</code></a> if called.
 <p>
 The type of the call site is permanently set to the given type.
 <p>
 Before this <code>CallSite</code> object is returned from a bootstrap method,
 or invoked in some other manner,
 it is usually provided with a more useful target method,
 via a call to <a href="CallSite.html#setTarget(java.lang.invoke.MethodHandle)"><code>setTarget</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>type</code> - the method type that this call site will have</dd>
<dt>Throws:</dt>
<dd><code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - if the proposed type is null</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="&lt;init&gt;(java.lang.invoke.MethodHandle)">
<h3>MutableCallSite</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">MutableCallSite</span><wbr><span class="parameters">(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target)</span></div>
<div class="block">Creates a call site object with an initial target method handle.
 The type of the call site is permanently set to the initial target's type.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>target</code> - the method handle that will be the initial target of the call site</dd>
<dt>Throws:</dt>
<dd><code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - if the proposed target is null</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="getTarget()">
<h3>getTarget</h3>
<div class="member-signature"><span class="modifiers">public final</span>&nbsp;<span class="return-type"><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></span>&nbsp;<span class="element-name">getTarget</span>()</div>
<div class="block">Returns the target method of the call site, which behaves
 like a normal field of the <code>MutableCallSite</code>.
 <p>
 The interactions of <code>getTarget</code> with memory are the same
 as of a read from an ordinary variable, such as an array element or a
 non-volatile, non-final field.
 <p>
 In particular, the current thread may choose to reuse the result
 of a previous read of the target from memory, and may fail to see
 a recent update to the target by another thread.</div>
<dl class="notes">
<dt>Specified by:</dt>
<dd><code><a href="CallSite.html#getTarget()">getTarget</a></code>&nbsp;in class&nbsp;<code><a href="CallSite.html" title="class in java.lang.invoke">CallSite</a></code></dd>
<dt>Returns:</dt>
<dd>the linkage state of this call site, a method handle which can change over time</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#setTarget(java.lang.invoke.MethodHandle)"><code>setTarget(java.lang.invoke.MethodHandle)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="setTarget(java.lang.invoke.MethodHandle)">
<h3>setTarget</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">setTarget</span><wbr><span class="parameters">(<a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;newTarget)</span></div>
<div class="block">Updates the target method of this call site, as a normal variable.
 The type of the new target must agree with the type of the old target.
 <p>
 The interactions with memory are the same
 as of a write to an ordinary variable, such as an array element or a
 non-volatile, non-final field.
 <p>
 In particular, unrelated threads may fail to see the updated target
 until they perform a read from memory.
 Stronger guarantees can be created by putting appropriate operations
 into the bootstrap method and/or the target methods used
 at any given call site.</div>
<dl class="notes">
<dt>Specified by:</dt>
<dd><code><a href="CallSite.html#setTarget(java.lang.invoke.MethodHandle)">setTarget</a></code>&nbsp;in class&nbsp;<code><a href="CallSite.html" title="class in java.lang.invoke">CallSite</a></code></dd>
<dt>Parameters:</dt>
<dd><code>newTarget</code> - the new target</dd>
<dt>Throws:</dt>
<dd><code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - if the proposed new target is null</dd>
<dd><code><a href="WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> - if the proposed new target
         has a method type that differs from the previous target</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="#getTarget()"><code>getTarget()</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="dynamicInvoker()">
<h3>dynamicInvoker</h3>
<div class="member-signature"><span class="modifiers">public final</span>&nbsp;<span class="return-type"><a href="MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></span>&nbsp;<span class="element-name">dynamicInvoker</span>()</div>
<div class="block">Produces a method handle equivalent to an invokedynamic instruction
 which has been linked to this call site.
 <p>
 This method is equivalent to the following code:
 <blockquote><pre><code>
 MethodHandle getTarget, invoker, result;
 getTarget = MethodHandles.publicLookup().bind(this, "getTarget", MethodType.methodType(MethodHandle.class));
 invoker = MethodHandles.exactInvoker(this.type());
 result = MethodHandles.foldArguments(invoker, getTarget)
 </code></pre></blockquote></div>
<dl class="notes">
<dt>Specified by:</dt>
<dd><code><a href="CallSite.html#dynamicInvoker()">dynamicInvoker</a></code>&nbsp;in class&nbsp;<code><a href="CallSite.html" title="class in java.lang.invoke">CallSite</a></code></dd>
<dt>Returns:</dt>
<dd>a method handle which always invokes this call site's current target</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="syncAll(java.lang.invoke.MutableCallSite[])">
<h3>syncAll</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">syncAll</span><wbr><span class="parameters">(<a href="MutableCallSite.html" title="class in java.lang.invoke">MutableCallSite</a>[]&nbsp;sites)</span></div>
<div class="block">Performs a synchronization operation on each call site in the given array,
 forcing all other threads to throw away any cached values previously
 loaded from the target of any of the call sites.
 <p>
 This operation does not reverse any calls that have already started
 on an old target value.
 (Java supports <a href="../Object.html#wait()">forward time travel</a> only.)
 <p>
 The overall effect is to force all future readers of each call site's target
 to accept the most recently stored value.
 ("Most recently" is reckoned relative to the <code>syncAll</code> itself.)
 Conversely, the <code>syncAll</code> call may block until all readers have
 (somehow) decached all previous versions of each call site's target.
 <p>
 To avoid race conditions, calls to <code>setTarget</code> and <code>syncAll</code>
 should generally be performed under some sort of mutual exclusion.
 Note that reader threads may observe an updated target as early
 as the <code>setTarget</code> call that install the value
 (and before the <code>syncAll</code> that confirms the value).
 On the other hand, reader threads may observe previous versions of
 the target until the <code>syncAll</code> call returns
 (and after the <code>setTarget</code> that attempts to convey the updated version).
 <p>
 This operation is likely to be expensive and should be used sparingly.
 If possible, it should be buffered for batch processing on sets of call sites.
 <p>
 If <code>sites</code> contains a null element,
 a <code>NullPointerException</code> will be raised.
 In this case, some non-null elements in the array may be
 processed before the method returns abnormally.
 Which elements these are (if any) is implementation-dependent.

 <h4>Java Memory Model details</h4>
 In terms of the Java Memory Model, this operation performs a synchronization
 action which is comparable in effect to the writing of a volatile variable
 by the current thread, and an eventual volatile read by every other thread
 that may access one of the affected call sites.
 <p>
 The following effects are apparent, for each individual call site <code>S</code>:
 <ul>
 <li>A new volatile variable <code>V</code> is created, and written by the current thread.
     As defined by the JMM, this write is a global synchronization event.
 <li>As is normal with thread-local ordering of write events,
     every action already performed by the current thread is
     taken to happen before the volatile write to <code>V</code>.
     (In some implementations, this means that the current thread
     performs a global release operation.)
 <li>Specifically, the write to the current target of <code>S</code> is
     taken to happen before the volatile write to <code>V</code>.
 <li>The volatile write to <code>V</code> is placed
     (in an implementation specific manner)
     in the global synchronization order.
 <li>Consider an arbitrary thread <code>T</code> (other than the current thread).
     If <code>T</code> executes a synchronization action <code>A</code>
     after the volatile write to <code>V</code> (in the global synchronization order),
     it is therefore required to see either the current target
     of <code>S</code>, or a later write to that target,
     if it executes a read on the target of <code>S</code>.
     (This constraint is called "synchronization-order consistency".)
 <li>The JMM specifically allows optimizing compilers to elide
     reads or writes of variables that are known to be useless.
     Such elided reads and writes have no effect on the happens-before
     relation.  Regardless of this fact, the volatile <code>V</code>
     will not be elided, even though its written value is
     indeterminate and its read value is not used.
 </ul>
 Because of the last point, the implementation behaves as if a
 volatile read of <code>V</code> were performed by <code>T</code>
 immediately after its action <code>A</code>.  In the local ordering
 of actions in <code>T</code>, this read happens before any future
 read of the target of <code>S</code>.  It is as if the
 implementation arbitrarily picked a read of <code>S</code>'s target
 by <code>T</code>, and forced a read of <code>V</code> to precede it,
 thereby ensuring communication of the new target value.
 <p>
 As long as the constraints of the Java Memory Model are obeyed,
 implementations may delay the completion of a <code>syncAll</code>
 operation while other threads (<code>T</code> above) continue to
 use previous values of <code>S</code>'s target.
 However, implementations are (as always) encouraged to avoid
 livelock, and to eventually require all threads to take account
 of the updated target.

 <p style="font-size:smaller;">
 <em>Discussion:</em>
 For performance reasons, <code>syncAll</code> is not a virtual method
 on a single call site, but rather applies to a set of call sites.
 Some implementations may incur a large fixed overhead cost
 for processing one or more synchronization operations,
 but a small incremental cost for each additional call site.
 In any case, this operation is likely to be costly, since
 other threads may have to be somehow interrupted
 in order to make them notice the updated target value.
 However, it may be observed that a single call to synchronize
 several sites has the same formal effect as many calls,
 each on just one of the sites.

 <p style="font-size:smaller;">
 <em>Implementation Note:</em>
 Simple implementations of <code>MutableCallSite</code> may use
 a volatile variable for the target of a mutable call site.
 In such an implementation, the <code>syncAll</code> method can be a no-op,
 and yet it will conform to the JMM behavior documented above.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>sites</code> - an array of call sites to be synchronized</dd>
<dt>Throws:</dt>
<dd><code><a href="../NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - if the <code>sites</code> array reference is null
                              or the array contains a null</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small><a href="https://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="https://docs.oracle.com/pls/topic/lookup?ctx=javase17&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples. <a href="https://docs.oracle.com/en/java/javase/index.html">Other versions.</a><br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../legal/copyright.html">Copyright</a> &copy; 1993, 2023, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="https://www.oracle.com/java/javase/terms/license/java17speclicense.html">license terms</a> and the <a href="https://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. <br><strong>DRAFT 17-crac+6-21</strong> <!-- Version 17-crac+6-21 --></small></p>
</footer>
</div>
</div>
</body>
</html>
