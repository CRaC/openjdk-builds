<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) -->
<title>MXBean (Java SE 17 &amp; JDK 17 [build 4])</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: module: java.management, package: javax.management, annotation type: MXBean">
<meta name="generator" content="javadoc/ClassWriterImpl">
<meta name="keywords" content="javax.management.MXBean class">
<meta name="keywords" content="value()">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header"><div style="padding: 6px; text-align: center; font-size: 80%; font-family: DejaVu Sans, Arial, Helvetica, sans-serif; font-weight: normal;">This specification is not final and is subject to change. Use is subject to <a href="https://www.oracle.com/java/javase/terms/license/java17speclicense.html">license terms</a>.</div>
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<div class="about-language"><div style="margin-top: 9px;"><strong>Java SE 17 &amp; JDK 17</strong> <br><strong>DRAFT 17-crac+4-17</strong></div></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/MXBean.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../preview-list.html">Preview</a></li>
<li><a href="../../../new-list.html">New</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../help-doc.html#class">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#annotation-interface-optional-element-summary">Optional</a>&nbsp;|&nbsp;</li>
<li>Required</li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#annotation-interface-element-detail">Element</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" value="search" disabled="disabled">
<input type="reset" id="reset-button" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="module-label-in-type">Module</span>&nbsp;<a href="../../module-summary.html">java.management</a></div>
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">javax.management</a></div>
<h1 title="Annotation Interface MXBean" class="title">Annotation Interface MXBean</h1>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="annotations"><a href="../../../java.base/java/lang/annotation/Documented.html" title="annotation interface in java.lang.annotation">@Documented</a>
<a href="../../../java.base/java/lang/annotation/Retention.html" title="annotation interface in java.lang.annotation">@Retention</a>(<a href="../../../java.base/java/lang/annotation/RetentionPolicy.html#RUNTIME">RUNTIME</a>)
<a href="../../../java.base/java/lang/annotation/Target.html" title="annotation interface in java.lang.annotation">@Target</a>(<a href="../../../java.base/java/lang/annotation/ElementType.html#TYPE">TYPE</a>)
</span><span class="modifiers">public @interface </span><span class="element-name type-name-label">MXBean</span></div>
<div class="block"><p>Annotation to mark an interface explicitly as being an MXBean
    interface, or as not being an MXBean interface.  By default, an
    interface is an MXBean interface if it is public and its name ends
    with <code>MXBean</code>, as in <code>SomethingMXBean</code>.  The following
    interfaces are MXBean interfaces:</p>

    <pre>
    public interface WhatsitMXBean {}

    &#64;MXBean
    public interface Whatsit1Interface {}

    &#64;MXBean(true)
    public interface Whatsit2Interface {}
    </pre>

    <p>The following interfaces are not MXBean interfaces:</p>

    <pre>
    interface NonPublicInterfaceNotMXBean{}

    public interface Whatsit3Interface{}

    &#64;MXBean(false)
    public interface MisleadingMXBean {}
    </pre>

    <h2 id="MXBean-spec">MXBean specification</h2>

    <p>The MXBean concept provides a simple way to code an MBean
      that only references a predefined set of types, the ones defined
      by <a href="openmbean/package-summary.html"><code>javax.management.openmbean</code></a>.  In this way, you can be
      sure that your MBean will be usable by any client, including
      remote clients, without any requirement that the client have
      access to <em>model-specific classes</em> representing the types
      of your MBeans.</p>

    <p>The concepts are easier to understand by comparison with the
      Standard MBean concept.  Here is how a managed object might be
      represented as a Standard MBean, and as an MXBean:</p>

    <div style="display:inline-block; margin: 0 3em">
        <h3>Standard MBean</h3>
        <pre>
public interface MemoryPool<b>MBean</b> {
    String getName();
    MemoryUsage getUsage();
    // ...
}
          </pre>
    </div>
    <div style="display:inline-block; margin: 0 3em">
        <h3>MXBean</h3>
        <pre>
public interface MemoryPool<b>MXBean</b> {
    String getName();
    MemoryUsage getUsage();
    // ...
}
          </pre>
    </div>

    <p>As you can see, the definitions are very similar.  The only
      difference is that the convention for naming the interface is to use
      <code><em>Something</em>MXBean</code> for MXBeans, rather than
      <code><em>Something</em>MBean</code> for Standard MBeans.</p>

    <p>In this managed object, there is an attribute called
      <code>Usage</code> of type <a href="../../java/lang/management/MemoryUsage.html" title="class in java.lang.management"><code>MemoryUsage</code></a>.  The point of an
      attribute like this is that it gives a coherent snapshot of a set
      of data items.  For example, it might include the current amount
      of used memory in the memory pool, and the current maximum of the
      memory pool.  If these were separate items, obtained with separate
      <a href="MBeanServer.html#getAttribute(javax.management.ObjectName,java.lang.String)"><code>getAttribute</code></a> calls, then we could
      get values seen at different times that were not consistent.  We
      might get a <code>used</code> value that was greater than the
      <code>max</code> value.</p>

    <p>So, we might define <code>MemoryUsage</code> like this:</p>

    <div style="display:inline-block; margin: 0 3em">
        <h3>Standard MBean</h3>
        <pre>
public class MemoryUsage <b>implements Serializable</b> {
    // standard JavaBean conventions with getters

    public MemoryUsage(long init, long used,
                       long committed, long max) {...}
    long getInit() {...}
    long getUsed() {...}
    long getCommitted() {...}
    long getMax() {...}
}
        </pre>
    </div>
    <div style="display:inline-block; margin: 0 3em">
        <h3>MXBean</h3>
        <pre>
public class MemoryUsage {
    // standard JavaBean conventions with getters
    <b>&#64;ConstructorParameters({"init", "used", "committed", "max"})</b>
    public MemoryUsage(long init, long used,
                       long committed, long max) {...}
    long getInit() {...}
    long getUsed() {...}
    long getCommitted() {...}
    long getMax() {...}
}
        </pre>
    </div>

    <p>The definitions are the same in the two cases, except
      that with the MXBean, <code>MemoryUsage</code> no longer needs to
      be marked <code>Serializable</code> (though it can be).  On
      the other hand, we have added a <a href="ConstructorParameters.html" title="annotation interface in javax.management"><code>&#64;ConstructorParameters</code></a>
      annotation to link the constructor parameters to the corresponding getters.
      We will see more about this below.</p>

    <p><code>MemoryUsage</code> is a <em>model-specific class</em>.
      With Standard MBeans, a client of the MBean Server cannot access the
      <code>Usage</code> attribute if it does not know the class
      <code>MemoryUsage</code>.  Suppose the client is a generic console
      based on JMX technology.  Then the console would have to be
      configured with the model-specific classes of every application it
      might connect to.  The problem is even worse for clients that are
      not written in the Java language.  Then there may not be any way
      to tell the client what a <code>MemoryUsage</code> looks like.</p>

    <p>This is where MXBeans differ from Standard MBeans.  Although we
      define the management interface in almost exactly the same way,
      the MXBean framework <em>converts</em> model-specific classes into
      standard classes from the Java platform.  Using arrays and the
      <a href="openmbean/CompositeData.html" title="interface in javax.management.openmbean"><code>CompositeData</code></a> and
      <a href="openmbean/TabularData.html" title="interface in javax.management.openmbean"><code>TabularData</code></a> classes
      from the standard <a href="openmbean/package-summary.html"><code>javax.management.openmbean</code></a> package, it
      is possible to build data structures of arbitrary complexity
      using only standard classes.</p>

    <p>This becomes clearer if we compare what the clients of the two
      models might look like:</p>

    <div style="display:inline-block; margin: 0 3em">
        <h3>Standard MBean</h3>
        <pre>
String name = (String)
    mbeanServer.<a href="MBeanServer.html#getAttribute(javax.management.ObjectName,java.lang.String)"><code>getAttribute</code></a>(objectName, "Name");
<b>MemoryUsage</b> usage = (<b>MemoryUsage</b>)
    mbeanServer.getAttribute(objectName, "Usage");
<b>long used = usage.getUsed();</b>
        </pre>
    </div>
    <div style="display:inline-block; margin: 0 3em">
        <h3>MXBean</h3>
        <pre>
String name = (String)
    mbeanServer.<a href="MBeanServer.html#getAttribute(javax.management.ObjectName,java.lang.String)"><code>getAttribute</code></a>(objectName, "Name");
<b><a href="openmbean/CompositeData.html" title="interface in javax.management.openmbean"><code>CompositeData</code></a></b> usage = (<b>CompositeData</b>)
    mbeanServer.getAttribute(objectName, "Usage");
<b>long used = (Long) usage.<a href="openmbean/CompositeData.html#get(java.lang.String)"><code>get</code></a>("used");</b>
        </pre>
    </div>

    <p>For attributes with simple types like <code>String</code>, the
      code is the same.  But for attributes with complex types, the
      Standard MBean code requires the client to know the model-specific
      class <code>MemoryUsage</code>, while the MXBean code requires no
      non-standard classes.</p>

    <p>The client code shown here is slightly more complicated for the
      MXBean client.  But, if the client does in fact know the model,
      here the interface <code>MemoryPoolMXBean</code> and the
      class <code>MemoryUsage</code>, then it can construct a
      <em>proxy</em>.  This is the recommended way to interact with
      managed objects when you know the model beforehand, regardless
      of whether you are using Standard MBeans or MXBeans:</p>

    <div style="display:inline-block; margin: 0 3em">
        <h3>Standard MBean</h3>
        <pre>
MemoryPool<b>MBean</b> proxy =
    JMX.<b><a href="JMX.html#newMBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)"><code>newMBeanProxy</code></a></b>(
        mbeanServer,
        objectName,
        MemoryPool<b>MBean</b>.class);
String name = proxy.getName();
MemoryUsage usage = proxy.getUsage();
long used = usage.getUsed();
          </pre>
    </div>
    <div style="display:inline-block; margin: 0 3em">
        <h3>MXBean</h3>
        <pre>
MemoryPool<b>MXBean</b> proxy =
    JMX.<b><a href="JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)"><code>newMXBeanProxy</code></a></b>(
        mbeanServer,
        objectName,
        MemoryPool<b>MXBean</b>.class);
String name = proxy.getName();
MemoryUsage usage = proxy.getUsage();
long used = usage.getUsed();
          </pre>
    </div>

    <p>Implementing the MemoryPool object works similarly for both
      Standard MBeans and MXBeans.</p>

    <div style="display:inline-block; margin: 0 3em">
        <h3>Standard MBean</h3>
        <pre>
public class MemoryPool
        implements MemoryPool<b>MBean</b> {
    public String getName() {...}
    public MemoryUsage getUsage() {...}
    // ...
}
        </pre>
    </div>
    <div style="display:inline-block; margin: 0 3em">
        <h3>MXBean</h3>
        <pre>
public class MemoryPool
        implements MemoryPool<b>MXBean</b> {
    public String getName() {...}
    public MemoryUsage getUsage() {...}
    // ...
}
        </pre>
    </div>

    <p>Registering the MBean in the MBean Server works in the same way
      in both cases:</p>

    <div style="display:inline-block; margin: 0 3em">
        <h3>Standard MBean</h3>
        <pre>
{
    MemoryPool<b>MBean</b> pool = new MemoryPool();
    mbeanServer.<a href="MBeanServer.html#registerMBean(java.lang.Object,javax.management.ObjectName)"><code>registerMBean</code></a>(pool, objectName);
}
        </pre>
    </div>
    <div style="display:inline-block; margin: 0 3em">
        <h3>MXBean</h3>
        <pre>
{
    MemoryPool<b>MXBean</b> pool = new MemoryPool();
    mbeanServer.<a href="MBeanServer.html#registerMBean(java.lang.Object,javax.management.ObjectName)"><code>registerMBean</code></a>(pool, objectName);
}
        </pre>
    </div>


    <h2 id="mxbean-def">Definition of an MXBean</h2>

    <p>An MXBean is a kind of MBean.  An MXBean object can be
      registered directly in the MBean Server, or it can be used as an
      argument to <a href="StandardMBean.html" title="class in javax.management"><code>StandardMBean</code></a> and the resultant MBean
      registered in the MBean Server.</p>

    <p>When an object is registered in the MBean Server using the
      <code>registerMBean</code> or <code>createMBean</code> methods of the
      <a href="MBeanServer.html" title="interface in javax.management"><code>MBeanServer</code></a> interface, the object's class is examined
      to determine what type of MBean it is:</p>

    <ul>
      <li>If the class implements the interface <a href="DynamicMBean.html" title="interface in javax.management"><code>DynamicMBean</code></a>
        then the MBean is a Dynamic MBean.  Note that the class
        <code>StandardMBean</code> implements this interface, so this
        case applies to a Standard MBean or MXBean created using
        the class <code>StandardMBean</code>.</li>

      <li>Otherwise, if the class matches the Standard MBean naming
        conventions, then the MBean is a Standard MBean.</li>

      <li>Otherwise, it may be an MXBean.  The set of interfaces
        implemented by the object is examined for interfaces that:

        <ul>
          <li>have a class name <code><em>S</em>MXBean</code> where
            <code><em>S</em></code> is any non-empty string, and
            do not have an annotation <code>@MXBean(false)</code>; and/or</li>
          <li>have an annotation <code>@MXBean(true)</code>
            or just <code>@MXBean</code>.</li>
        </ul>

        If there is exactly one such interface, or if there is one
        such interface that is a subinterface of all the others, then
        the object is an MXBean.  The interface in question is the
        <em>MXBean interface</em>.  In the example above, the MXBean
        interface is <code>MemoryPoolMXBean</code>.

      <li>If none of these conditions is met, the MBean is invalid and
        the attempt to register it will generate <a href="NotCompliantMBeanException.html" title="class in javax.management"><code>NotCompliantMBeanException</code></a>.
    </ul>

    <p>Every Java type that appears as the parameter or return type of a
      method in an MXBean interface must be <em>convertible</em> using
      the rules below.  Additionally, parameters must be
      <em>reconstructible</em> as defined below.</p>

    <p>An attempt to construct an MXBean that does not conform to the
      above rules will produce an exception.</p>


    <h2 id="naming-conv">Naming conventions</h2>

    <p>The same naming conventions are applied to the methods in an
      MXBean as in a Standard MBean:</p>

    <ol>
      <li>A method <code><em>T</em> get<em>N</em>()</code>, where
        <code><em>T</em></code> is a Java type (not <code>void</code>)
        and <code><em>N</em></code> is a non-empty string, specifies
        that there is a readable attribute called
        <code><em>N</em></code>.  The Java type and Open type of the
        attribute are determined by the mapping rules below.
        The method <code>final Class getClass()</code> inherited from <code>
        Object</code> is ignored when looking for getters.</li>

      <li>A method <code>boolean is<em>N</em>()</code> specifies that
        there is a readable attribute called <code><em>N</em></code>
        with Java type <code>boolean</code> and Open type
        <code>SimpleType.Boolean</code>.</li>

      <li>A method <code>void set<em>N</em>(<em>T</em> x)</code>
        specifies that there is a writeable attribute called
        <code><em>N</em></code>.  The Java type and Open type of the
        attribute are determined by the mapping rules below.  (Of
        course, the name <code>x</code> of the parameter is
        irrelevant.)</li>

      <li>Every other method specifies that there is an operation with
        the same name as the method.  The Java type and Open type of the
        return value and of each parameter are determined by the mapping
        rules below.</li>
    </ol>

    <p>The rules for <code>get<em>N</em></code> and
      <code>is<em>N</em></code> collectively define the notion of a
      <em>getter</em>.  The rule for <code>set<em>N</em></code> defines
      the notion of a <em>setter</em>.</p>

    <p>It is an error for there to be two getters with the same name, or
      two setters with the same name.  If there is a getter and a setter
      for the same name, then the type <code><em>T</em></code> in both
      must be the same.  In this case the attribute is read/write.  If
      there is only a getter or only a setter, the attribute is
      read-only or write-only respectively.</p>


    <h2 id="mapping-rules">Type mapping rules</h2>

    <p>An MXBean is a kind of Open MBean, as defined by the <a href="openmbean/package-summary.html"><code>javax.management.openmbean</code></a> package.  This means that the types of
      attributes, operation parameters, and operation return values must
      all be describable using <em>Open Types</em>, that is the four
      standard subclasses of <a href="openmbean/OpenType.html" title="class in javax.management.openmbean"><code>OpenType</code></a>.
      MXBeans achieve this by mapping Java types into Open Types.</p>

    <p>For every Java type <em>J</em>, the MXBean mapping is described
      by the following information:</p>

    <ul>
      <li>The corresponding Open Type, <em>opentype(J)</em>.  This is
        an instance of a subclass of <a href="openmbean/OpenType.html" title="class in javax.management.openmbean"><code>OpenType</code></a>.</li>
      <li>The <em>mapped</em> Java type, <em>opendata(J)</em>, which is
        always the same for any given <em>opentype(J)</em>.  This is a Java
        class.</li>
      <li>How a value is converted from type <em>J</em> to type
        <em>opendata(J)</em>.</li>
      <li>How a value is converted from type <em>opendata(J)</em> to
        type <em>J</em>, if it can be.</li>
    </ul>

    <p>For example, for the Java type <code>List&lt;String&gt;</code>:</p>

    <ul>
      <li>The Open Type, <em>opentype(</em><code>
        List&lt;String&gt;</code><em>)</em>, is <a href="openmbean/ArrayType.html" title="class in javax.management.openmbean"><code>ArrayType</code></a><code>(1, </code><a href="openmbean/SimpleType.html#STRING"><code>SimpleType.STRING</code></a><code>)</code>, representing a 1-dimensional
          array of <code>String</code>s.</li>
      <li>The mapped Java type, <em>opendata(</em><code>
        List&lt;String&gt;</code><em>)</em>, is <code>String[]</code>.</li>
      <li>A <code>List&lt;String&gt;</code> can be converted to a <code>String[]</code>
          using <a href="../../../java.base/java/util/List.html#toArray(T%5B%5D)"><code>List.toArray(new
          String[0])</code></a>.</li>
      <li>A <code>String[]</code> can be converted to a <code>List&lt;String&gt;</code>
          using <a href="../../../java.base/java/util/Arrays.html#asList(T...)"><code>Arrays.asList</code></a>.</li>
    </ul>

    <p>If no mapping rules exist to derive <em>opentype(J)</em> from
      <em>J</em>, then <em>J</em> cannot be the type of a method
      parameter or return value in an MXBean interface.</p>

    <p id="reconstructible-def">If there is a way to convert
      <em>opendata(J)</em> back to <em>J</em> then we say that <em>J</em> is
      <em>reconstructible</em>.  All method parameters in an MXBean
      interface must be reconstructible, because when the MXBean
      framework is invoking a method it will need to convert those
      parameters from <em>opendata(J)</em> to <em>J</em>.  In a proxy
      generated by <a href="JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)"><code>JMX.newMXBeanProxy</code></a>, it is the return values
      of the methods in the MXBean interface that must be
      reconstructible.</p>

    <p>Null values are allowed for all Java types and Open Types,
      except primitive Java types where they are not possible.  When
      converting from type <em>J</em> to type <em>opendata(J)</em> or
      from type <em>opendata(J)</em> to type <em>J</em>, a null value is
      mapped to a null value.</p>

    <p>The following table summarizes the type mapping rules.</p>

    <table class="striped">
    <caption style="display:none">Type Mapping Rules</caption>
      <thead>
      <tr>
        <th scope="col">Java type <em>J</em></th>
        <th scope="col"><em>opentype(J)</em></th>
        <th scope="col"><em>opendata(J)</em></th>
      </tr>
      </thead>
      <tbody style="text-align:left; vertical-align:top">
        <tr>
          <th scope="row"><code>int</code>, <code>boolean</code>, etc<br>
            (the 8 primitive Java types)</th>
          <td><code>SimpleType.INTEGER</code>,<br>
            <code>SimpleType.BOOLEAN</code>, etc</td>
          <td><code>Integer</code>, <code>Boolean</code>, etc<br>
            (the corresponding boxed types)</td>
        </tr>
        <tr>
          <th scope="row"><code>Integer</code>, <code>ObjectName</code>, etc<br>
            (the types covered by <a href="openmbean/SimpleType.html" title="class in javax.management.openmbean"><code>SimpleType</code></a>)</th>
          <td>the corresponding <code>SimpleType</code></td>
          <td><em>J</em>, the same type</td>
        </tr>
        <tr>
          <th scope="row"><code>int[]</code> etc<br>
            (a one-dimensional array with primitive element type)</th>
          <td><code>ArrayType.getPrimitiveArrayType(int[].class)</code> etc</td>
          <td><em>J</em>, the same type</td>
        <tr>
          <th scope="row"><em>E</em><code>[]</code><br>
            (an array with non-primitive element type <em>E</em>;
              this includes <code>int[][]</code>, where <em>E</em> is <code>int[]</code>)</th>
          <td><code>ArrayType.getArrayType(</code><em>opentype(E)</em><code>)</code></td>
          <td><em>opendata(E)</em><code>[]</code></td>
        </tr>
        <tr>
          <th scope="row"><code>List&lt;</code><em>E</em><code>&gt;</code><br>
            <code>Set&lt;</code><em>E</em><code>&gt;</code><br>
            <code>SortedSet&lt;</code><em>E</em><code>&gt;</code> (see below)</th>
          <td>same as for <em>E</em><code>[]</code></td>
          <td>same as for <em>E</em><code>[]</code></td>
        </tr>
        <tr>
          <th scope="row">An enumeration <em>E</em><br>
            (declared in Java as <code>enum </code><em>E</em>
            <code>{...}</code>)</th>
          <td><code>SimpleType.STRING</code></td>
          <td><code>String</code></td>
        </tr>
        <tr>
          <th scope="row"><code>Map&lt;</code><em>K</em>,<em>V</em><code>&gt;</code><br>
            <code>SortedMap&lt;</code><em>K</em>,<em>V</em><code>&gt;</code></th>
          <td><a href="openmbean/TabularType.html" title="class in javax.management.openmbean"><code>TabularType</code></a><br>
            (see below)</td>
          <td><a href="openmbean/TabularData.html" title="interface in javax.management.openmbean"><code>TabularData</code></a><br>
            (see below)</td>
        </tr>
        <tr>
          <th scope="row"><a href="../../../java.base/java/lang/Record.html" title="class in java.lang">Record classes</a></th>
          <td><a href="openmbean/CompositeType.html" title="class in javax.management.openmbean"><code>CompositeType</code></a>, if possible<br>
            (see below)</td>
          <td><a href="openmbean/CompositeData.html" title="interface in javax.management.openmbean"><code>CompositeData</code></a><br>
            (see below)</td>
        </tr>
        <tr>
          <th scope="row">An MXBean interface</th>
          <td><code>SimpleType.OBJECTNAME</code><br>
            (see below)</td>
          <td><a href="ObjectName.html" title="class in javax.management"><code>ObjectName</code></a><br>
            (see below)</td>
        </tr>
        <tr>
          <th scope="row">Any other type</th>
          <td><a href="openmbean/CompositeType.html" title="class in javax.management.openmbean"><code>CompositeType</code></a>,
            if possible<br>
            (see below)</td>
          <td><a href="openmbean/CompositeData.html" title="interface in javax.management.openmbean"><code>CompositeData</code></a><br>
            (see below)</td>
      </tbody>
    </table>

    <p>The following sections give further details of these rules.</p>


    <h3>Mappings for primitive types</h3>

    <p>The 8 primitive Java types
      (<code>boolean</code>, <code>byte</code>, <code>short</code>, <code>int</code>, <code>
      long</code>, <code>float</code>, <code>double</code>, <code>char</code>) are mapped to the
      corresponding boxed types from <code>java.lang</code>, namely <code>
      Boolean</code>, <code>Byte</code>, etc.  The Open Type is the corresponding
      <code>SimpleType</code>.  Thus, <em>opentype(</em><code>
      long</code><em>)</em> is <code>SimpleType.LONG</code>, and
      <em>opendata(</em><code>long</code><em>)</em> is <code>
      java.lang.Long</code>.</p>

    <p>An array of primitive type such as <code>long[]</code> can be represented
      directly as an Open Type.  Thus, <em>openType(</em><code>
      long[]</code><em>)</em> is <code>
      ArrayType.getPrimitiveArrayType(long[].class)</code>, and
      <em>opendata(</em><code>long[]</code><em>)</em> is <code>
      long[]</code>.</p>

    <p>In practice, the difference between a plain <code>int</code> and <code>
      Integer</code>, etc, does not show up because operations in the JMX API
      are always on Java objects, not primitives.  However, the
      difference <em>does</em> show up with arrays.</p>


    <h3>Mappings for collections (<code>List&lt;</code><em>E</em><code>&gt;</code> etc)</h3>

    <p>A <code>List&lt;</code><em>E</em><code>&gt;</code> or <code>
      Set&lt;</code><em>E</em><code>&gt;</code>, such as <code>List&lt;String&gt;</code> or <code>
        Set&lt;ObjectName&gt;</code>, is mapped in the same way as an array of the
          same element type, such as <code>String[]</code> or <code>
          ObjectName[]</code>.</p>

    <p>A <code>SortedSet&lt;</code><em>E</em><code>&gt;</code> is also mapped in the
      same way as an <em>E</em><code>[]</code>, but it is only convertible if
      <em>E</em> is a class or interface that implements <a href="../../../java.base/java/lang/Comparable.html" title="interface in java.lang"><code>Comparable</code></a>.  Thus, a <code>SortedSet&lt;String&gt;</code> or
        <code>SortedSet&lt;Integer&gt;</code> is convertible, but a <code>
          SortedSet&lt;int[]&gt;</code> or <code>SortedSet&lt;List&lt;String&gt;&gt;</code> is not.  The
                conversion of a <code>SortedSet</code> instance will fail with an
                <code>IllegalArgumentException</code> if it has a
                non-null <a href="../../../java.base/java/util/SortedSet.html#comparator()"><code>comparator()</code></a>.</p>

    <p>A <code>List&lt;</code><em>E</em><code>&gt;</code> is reconstructed as a
      <code>java.util.ArrayList&lt;</code><em>E</em><code>&gt;</code>;
      a <code>Set&lt;</code><em>E</em><code>&gt;</code> as a
      <code>java.util.HashSet&lt;</code><em>E</em><code>&gt;</code>;
      a <code>SortedSet&lt;</code><em>E</em><code>&gt;</code> as a
      <code>java.util.TreeSet&lt;</code><em>E</em><code>&gt;</code>.</p>


    <h3>Mappings for maps (<code>Map&lt;</code><em>K</em>,<em>V</em><code>&gt;</code> etc)</h3>

    <p>A <code>Map&lt;</code><em>K</em>,<em>V</em><code>&gt;</code> or <code>
      SortedMap&lt;</code><em>K</em>,<em>V</em><code>&gt;</code>, for example <code>
      Map&lt;String,ObjectName&gt;</code>, has Open Type <a href="openmbean/TabularType.html" title="class in javax.management.openmbean"><code>TabularType</code></a> and is mapped
        to a <a href="openmbean/TabularData.html" title="interface in javax.management.openmbean"><code>TabularData</code></a>.
        The <code>TabularType</code> has two items called <code>key</code> and
        <code>value</code>.  The Open Type of <code>key</code> is
        <em>opentype(K)</em>, and the Open Type of <code>value</code> is
        <em>opentype(V)</em>.  The index of the <code>TabularType</code> is the
        single item <code>key</code>.</p>

    <p>For example, the <code>TabularType</code> for a <code>
      Map&lt;String,ObjectName&gt;</code> might be constructed with code like
        this:</p>

    <pre>
String typeName =
    "java.util.Map&lt;java.lang.String, javax.management.ObjectName&gt;";
String[] keyValue =
    new String[] {"key", "value"};
OpenType[] openTypes =
    new OpenType[] {SimpleType.STRING, SimpleType.OBJECTNAME};
CompositeType rowType =
    new CompositeType(typeName, typeName, keyValue, keyValue, openTypes);
TabularType tabularType =
    new TabularType(typeName, typeName, rowType, new String[] {"key"});
    </pre>

    <p>The <code>typeName</code> here is determined by the <a href="#type-names">
      type name rules</a> detailed below.

    <p>A <code>SortedMap&lt;</code><em>K</em>,<em>V</em><code>&gt;</code> is mapped in the
      same way, but it is only convertible if
      <em>K</em> is a class or interface that implements <a href="../../../java.base/java/lang/Comparable.html" title="interface in java.lang"><code>Comparable</code></a>.  Thus, a <code>SortedMap&lt;String,int[]&gt;</code>
        is convertible, but a
        <code>SortedMap&lt;int[],String&gt;</code> is not.  The conversion of a
          <code>SortedMap</code> instance will fail with an <code>
          IllegalArgumentException</code> if it has a non-null <a href="../../../java.base/java/util/SortedMap.html#comparator()"><code>comparator()</code></a>.</p>

    <p>A <code>Map&lt;</code><em>K</em>,<em>V</em><code>&gt;</code> is reconstructed as
      a <code>java.util.HashMap&lt;</code><em>K</em>,<em>V</em><code>&gt;</code>;
      a <code>SortedMap&lt;</code><em>K</em>,<em>V</em><code>&gt;</code> as
      a <code>java.util.TreeMap&lt;</code><em>K</em>,<em>V</em><code>&gt;</code>.</p>

    <p><code>TabularData</code> is an interface.  The concrete class that is
      used to represent a <code>Map&lt;</code><em>K</em>,<em>V</em><code>&gt;</code> as
      Open Data is <a href="openmbean/TabularDataSupport.html" title="class in javax.management.openmbean"><code>TabularDataSupport</code></a>,
      or another class implementing <code>
      TabularData</code> that serializes as <code>TabularDataSupport</code>.</p>


    <h3 id="records">Mappings for Records</h3>

    <p>A <a href="../../../java.base/java/lang/Record.html" title="class in java.lang">record</a> class <em>J</em> can be converted
      to a <a href="openmbean/CompositeType.html" title="class in javax.management.openmbean"><code>CompositeType</code></a> if and only if all its
      <a href="../../../java.base/java/lang/Class.html#getRecordComponents()">components</a> are
      convertible to open types. Otherwise, it is not convertible.
      A record that has no components is not convertible.</p>

    <h4 id="record-type-map">Mapping a record class to
      <code>CompositeType</code></h4>

    <p>A record whose components are all convertible to open
      types, is itself convertible to a <a href="openmbean/CompositeType.html" title="class in javax.management.openmbean"><code>CompositeType</code></a>.
      The record class is converted to a <code>CompositeType</code>
      as follows.</p>

    <ul>
      <li>The type name of the <code>CompositeType</code> is the name
        of the record class.</li>

      <li>The record getters are the accessors for the
        <a href="../../../java.base/java/lang/reflect/RecordComponent.html" title="class in java.lang.reflect">record components</a>.</li>

      <li>For each record component of type <em>T</em>, the item in
        the <code>CompositeType</code> has the same name as the record
        component and its type is <em>opentype(T)</em>, as
        defined by the <a href="#mapping-rules">type mapping rules</a>
        above.</li>
    </ul>

    <h4 id="record-data-map">Mapping an instance of a record class to
      <code>CompositeData</code></h4>

    <p>The mapping from an instance of a record class to a
      <a href="openmbean/CompositeData.html" title="interface in javax.management.openmbean"><code>CompositeData</code></a> corresponding to the <code>CompositeType</code>
      is the same as specified for
      <a href="#composite-data-map">other types</a>.</p>

    <h4 id="reconstructing-record">Reconstructing an instance of a record class
      from a <code>CompositeData</code></h4>

    <p>A record is reconstructed using its canonical constructor.
      The canonical constructor doesn't require the presence of
      <a href="ConstructorParameters.html" title="annotation interface in javax.management"><code>&#64;javax.management.ConstructorParameters</code></a>
      or <code>@java.beans.ConstructorProperties</code> annotations. If these
      annotations are present on the canonical constructor they
      will be ignored.</p>

    <p>How an instance of a record class <em>J</em> is reconstructed
      from a <a href="openmbean/CompositeData.html" title="interface in javax.management.openmbean"><code>CompositeData</code></a> is detailed in
      <a href="#reconstructing">Reconstructing an instance
      of Java type or record class <em>J</em> from a <code>CompositeData</code></a>
      below.</p>

    <h3 id="mxbean-map">Mappings for MXBean interfaces</h3>

    <p>An MXBean interface, or a type referenced within an MXBean
      interface, can reference another MXBean interface, <em>J</em>.
      Then <em>opentype(J)</em> is <code>SimpleType.OBJECTNAME</code> and
      <em>opendata(J)</em> is <code>ObjectName</code>.</p>

    <p>For example, suppose you have two MXBean interfaces like this:</p>

    <pre>
public interface ProductMXBean {
    public ModuleMXBean[] getModules();
}

public interface ModuleMXBean {
    public ProductMXBean getProduct();
}
    </pre>

    <p>The object implementing the <code>ModuleMXBean</code> interface
      returns from its <code>getProduct</code> method an object
      implementing the <code>ProductMXBean</code> interface.  The
      <code>ModuleMXBean</code> object and the returned <code>
      ProductMXBean</code> objects must both be registered as MXBeans in the
      same MBean Server.</p>

    <p>The method <code>ModuleMXBean.getProduct()</code> defines an
      attribute called <code>Product</code>.  The Open Type for this
      attribute is <code>SimpleType.OBJECTNAME</code>, and the corresponding
      <code>ObjectName</code> value will be the name under which the
      referenced <code>ProductMXBean</code> is registered in the MBean
      Server.</p>

    <p>If you make an MXBean proxy for a <code>ModuleMXBean</code> and
      call its <code>getProduct()</code> method, the proxy will map the
      <code>ObjectName</code> back into a <code>ProductMXBean</code> by making
      another MXBean proxy.  More formally, when a proxy made with
      <a href="JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)"><code>JMX.newMXBeanProxy(mbeanServerConnection, objectNameX,
      interfaceX)</code></a> needs to map <code>objectNameY</code> back into <code>
      interfaceY</code>, another MXBean interface, it does so with <code>
      JMX.newMXBeanProxy(mbeanServerConnection, objectNameY,
      interfaceY)</code>.  The implementation may return a proxy that was
      previously created by a call to <code>JMX.newMXBeanProxy</code>
      with the same parameters, or it may create a new proxy.</p>

    <p>The reverse mapping is illustrated by the following change to the
      <code>ModuleMXBean</code> interface:</p>

    <pre>
public interface ModuleMXBean {
    public ProductMXBean getProduct();
    public void setProduct(ProductMXBean c);
}
    </pre>

    <p>The presence of the <code>setProduct</code> method now means that the
      <code>Product</code> attribute is read/write.  As before, the value
      of this attribute is an <code>ObjectName</code>.  When the attribute is
      set, the <code>ObjectName</code> must be converted into the
      <code>ProductMXBean</code> object that the <code>setProduct</code> method
      expects.  This object will be an MXBean proxy for the given
      <code>ObjectName</code> in the same MBean Server.</p>

    <p>If you make an MXBean proxy for a <code>ModuleMXBean</code> and
      call its <code>setProduct</code> method, the proxy will map its
      <code>ProductMXBean</code> argument back into an <code>ObjectName</code>.
      This will only work if the argument is in fact another proxy,
      for a <code>ProductMXBean</code> in the same <code>
      MBeanServerConnection</code>.  The proxy can have been returned from
      another proxy (like <code>ModuleMXBean.getProduct()</code> which
      returns a proxy for a <code>ProductMXBean</code>); or it can have
      been created by <a href="JMX.html#newMXBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)"><code>JMX.newMXBeanProxy</code></a>; or it can have been created using <a href="../../../java.base/java/lang/reflect/Proxy.html" title="class in java.lang.reflect"><code>Proxy</code></a> with an invocation handler that
      is <a href="MBeanServerInvocationHandler.html" title="class in javax.management"><code>MBeanServerInvocationHandler</code></a> or a subclass.</p>

    <p>If the same MXBean were registered under two different
      <code>ObjectName</code>s, a reference to that MXBean from another
      MXBean would be ambiguous.  Therefore, if an MXBean object is
      already registered in an MBean Server and an attempt is made to
      register it in the same MBean Server under another name, the
      result is an <a href="InstanceAlreadyExistsException.html" title="class in javax.management"><code>InstanceAlreadyExistsException</code></a>.  Registering
      the same MBean object under more than one name is discouraged in
      general, notably because it does not work well for MBeans that are
      <a href="NotificationBroadcaster.html" title="interface in javax.management"><code>NotificationBroadcaster</code></a>s.</p>

    <h3 id="composite-map">Mappings for other types</h3>

    <p>Given a Java class or interface <em>J</em> that does not match the other
      rules in the table above, the MXBean framework will attempt to map
      it to a <a href="openmbean/CompositeType.html" title="class in javax.management.openmbean"><code>CompositeType</code></a> as follows.  The type name of this
      <code>CompositeType</code> is determined by the <a href="#type-names">
      type name rules</a> below.</p>

    <h4 id="composite-type-map">Mapping a Java type <em>J</em>
      to <a href="openmbean/CompositeType.html" title="class in javax.management.openmbean"><code>CompositeType</code></a></h4>

    <p>The class is examined for getters using the conventions
      <a href="#naming-conv">above</a>.  (Getters must be public
      instance methods.)  If there are no getters, or if
      any getter has a type that is not convertible, then <em>J</em> is
      not convertible.</p>

    <p>If there is at least one getter and every getter has a
      convertible type, then <em>opentype(J)</em> is a <code>
      CompositeType</code> with one item for every getter.  If the getter is

    <blockquote>
      <code><em>T</em> get<em>Name</em>()</code>
    </blockquote>

    then the item in the <code>CompositeType</code> is called <code>name</code>
    and has type <em>opentype(T)</em>.  For example, if the item is

    <blockquote>
      <code>String getOwner()</code>
    </blockquote>

    then the item is called <code>owner</code> and has Open Type <code>
    SimpleType.STRING</code>.  If the getter is

    <blockquote>
      <code>boolean is<em>Name</em>()</code>
    </blockquote>

    then the item in the <code>CompositeType</code> is called <code>name</code>
    and has type <code>SimpleType.BOOLEAN</code>.

    <p>Notice that the first character (or code point) is converted to
      lower case.  This follows the Java Beans convention, which for
      historical reasons is different from the Standard MBean
      convention.  In a Standard MBean or MXBean interface, a method
      <code>getOwner</code> defines an attribute called <code>Owner</code>, while
      in a Java Bean or mapped <code>CompositeType</code>, a method <code>
      getOwner</code> defines a property or item called <code>owner</code>.</p>

    <p>If two methods produce the same item name (for example, <code>
      getOwner</code> and <code>isOwner</code>, or <code>getOwner</code> and <code>
      getowner</code>) then the type is not convertible.</p>

    <h4 id="composite-data-map">Mapping from an instance of Java
      type or record class <em>J</em> to <code>CompositeData</code></h4>

    <p>When the Open Type is <code>CompositeType</code>, the corresponding
      mapped Java type (<em>opendata(J)</em>) is <a href="openmbean/CompositeData.html" title="interface in javax.management.openmbean"><code>CompositeData</code></a>.  The mapping from an instance of <em>J</em> to a
      <code>CompositeData</code> corresponding to the <code>CompositeType</code>
      just described is done as follows.  First, if <em>J</em>
      implements the interface <a href="openmbean/CompositeDataView.html" title="interface in javax.management.openmbean"><code>CompositeDataView</code></a>, then that
      interface's <a href="openmbean/CompositeDataView.html#toCompositeData(javax.management.openmbean.CompositeType)"><code>toCompositeData</code></a> method is called to do the conversion.
      Otherwise, the <code>CompositeData</code> is constructed by calling
      the getter for each item and converting it to the corresponding
      Open Data type.  Thus, a getter such as</p>

    <blockquote>
      <code>List&lt;String&gt; getNames()</code> (or <code>List&lt;String&gt; names()</code> for a record)
    </blockquote>

    <p>will have been mapped to an item with name "<code>names</code>" and
      Open Type <code>ArrayType(1, SimpleType.STRING)</code>.  The conversion
      to <code>CompositeData</code> will call <code>getNames()</code> and convert
      the resultant <code>List&lt;String&gt;</code> into a <code>String[]</code> for the
        item "<code>names</code>".</p>

    <p><code>CompositeData</code> is an interface.  The concrete class that is
      used to represent a type as Open Data is <a href="openmbean/CompositeDataSupport.html" title="class in javax.management.openmbean"><code>CompositeDataSupport</code></a>, or another class implementing <code>
      CompositeData</code> that serializes as <code>
      CompositeDataSupport</code>.</p>


    <h4 id="reconstructing">Reconstructing an instance of Java type
      or record class <em>J</em> from a <code>CompositeData</code></h4>

    <p>If <em>opendata(J)</em> is <code>CompositeData</code> for a Java type
      <em>J</em>, then either an instance of <em>J</em> can be
      reconstructed from a <code>CompositeData</code>, or <em>J</em> is not
      reconstructible.  If any item in the <code>CompositeData</code> is not
      reconstructible, then <em>J</em> is not reconstructible either.</p>

    <p>For any given <em>J</em>, the following rules are consulted to
      determine how to reconstruct instances of <em>J</em> from
      <code>CompositeData</code>.  The first applicable rule in the list is
      the one that will be used.</p>

    <ol>

      <li><p>If <em>J</em> has a method<br>
        <code>public static </code><em>J </em><code>from(CompositeData cd)</code><br>
        then that method is called to reconstruct an instance of
        <em>J</em>.</p></li>

      <li><p>Otherwise, if <em>J</em> is a <a href="../../../java.base/java/lang/Record.html" title="class in java.lang"><code>Record</code></a> class,
        and the record canonical constructor is applicable,
        an instance of <em>J</em> is reconstructed by calling
        the record canonical constructor.
        The canonical constructor, if applicable, is called
        with the appropriate reconstructed items from the
        <code>CompositeData</code>. The canonical constructor
        is <em>applicable</em> if all the properties named
        by the record components are present in the
        <code>CompositeData</code>.</p></li>

      <li><p>Otherwise, if <em>J</em> has at least one public
        constructor with either <a href="ConstructorParameters.html" title="annotation interface in javax.management"><code>&#64;javax.management.ConstructorParameters</code></a> or
        <code>@java.beans.ConstructoProperties</code> annotation, then one of those
        constructors (not necessarily always the same one) will be called to
        reconstruct an instance of <em>J</em>.
        If a constructor is annotated with both
        <code>@javax.management.ConstructorParameters</code> and
        <code>@java.beans.ConstructorProperties</code>,
        <code>@javax.management.ConstructorParameters</code> will be used and
        <code>@java.beans.ConstructorProperties</code> will be ignored.
        Every such annotation must list as many strings as the
        constructor has parameters; each string must name a property
        corresponding to a getter of <em>J</em>; and the type of this
        getter must be the same as the corresponding constructor
        parameter.  It is not an error for there to be getters that
        are not mentioned in the <code>@ConstructorParameters</code> or
        <code>@ConstructorProperties</code> annotations (these may correspond to
        information that is not needed to reconstruct the object).</p>

        <p>An instance of <em>J</em> is reconstructed by calling a
        constructor with the appropriate reconstructed items from the
        <code>CompositeData</code>.  The constructor to be called will be
        determined at runtime based on the items actually present in
        the <code>CompositeData</code>, given that this <code>
        CompositeData</code> might come from an earlier version of
        <em>J</em> where not all the items were present.  A
        constructor is <em>applicable</em> if all the properties named
        in its <code>@ConstructorParameters</code> or <code>@ConstructorProperties</code>
        annotation are present as items in the <code>CompositeData</code>.
        If no constructor is applicable, then the attempt to reconstruct
        <em>J</em> fails.</p>

        <p>For any possible combination of properties, it must be the
        case that either (a) there are no applicable constructors, or
        (b) there is exactly one applicable constructor, or (c) one of
        the applicable constructors names a proper superset of the
        properties named by each other applicable constructor.  (In
        other words, there should never be ambiguity over which
        constructor to choose.)  If this condition is not true, then
        <em>J</em> is not reconstructible.</p></li>

      <li><p>Otherwise, if <em>J</em> has a public no-arg constructor, and
        for every getter in <em>J</em> with type
        <em>T</em> and name <em>N</em> there is a corresponding setter
        with the same name and type, then an instance of <em>J</em> is
        constructed with the no-arg constructor and the setters are
        called with the reconstructed items from the <code>CompositeData</code>
        to restore the values.  For example, if there is a method<br>
        <code>public List&lt;String&gt; getNames()</code><br>
          then there must also be a method<br>
          <code>public void setNames(List&lt;String&gt; names)</code><br>
            for this rule to apply.</p>

        <p>If the <code>CompositeData</code> came from an earlier version of
        <em>J</em>, some items might not be present.  In this case,
        the corresponding setters will not be called.</p></li>

      <li><p>Otherwise, if <em>J</em> is an interface that has no methods
        other than getters, an instance of <em>J</em> is constructed
        using a <a href="../../../java.base/java/lang/reflect/Proxy.html" title="class in java.lang.reflect"><code>Proxy</code></a> with a <a href="openmbean/CompositeDataInvocationHandler.html" title="class in javax.management.openmbean"><code>CompositeDataInvocationHandler</code></a> backed by the <code>
        CompositeData</code> being converted.</p></li>

      <li><p>Otherwise, <em>J</em> is not reconstructible.</p></li>
    </ol>

    <p>Rule 2 is not applicable when <code>java.beans.ConstructorProperties</code>
    is not visible (e.g. when the java.desktop module is not readable or when
    the runtime image does not contain the java.desktop module). When
    targeting a runtime that does not include the <code>java.beans</code> package,
    and where there is a mismatch between the compile-time and runtime
    environment whereby <em>J</em> is compiled with a public constructor
    and the <code>ConstructorProperties</code> annotation, then <em>J</em> is
    not reconstructible unless another rule applies.</p>

    <p>Here are examples showing different ways to code a type <code>
      NamedNumber</code> that consists of an <code>int</code> and a <code>
      String</code>.  In each case, the <code>CompositeType</code> looks like this:</p>

    <blockquote>
      <pre>
<a href="openmbean/CompositeType.html" title="class in javax.management.openmbean"><code>CompositeType</code></a>(
    "NamedNumber",                      // typeName
    "NamedNumber",                      // description
    new String[] {"number", "name"},    // itemNames
    new String[] {"number", "name"},    // itemDescriptions
    new OpenType[] {SimpleType.INTEGER,
                    SimpleType.STRING}  // itemTypes
);
      </pre>
    </blockquote>

    <ol>
      <li>Static <code>from</code> method:

        <blockquote>
          <pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public String getName() {return name;}
    private NamedNumber(int number, String name) {
        this.number = number;
        this.name = name;
    }
    <b>public static NamedNumber from(CompositeData cd)</b> {
        return new NamedNumber((Integer) cd.get("number"),
                               (String) cd.get("name"));
    }
    private final int number;
    private final String name;
}
          </pre>
        </blockquote>
      </li>

      <li>Record:

        <blockquote>
          <pre>
 public record NamedNumber(int number, String name) {}
          </pre>
        </blockquote>
      </li>

      <li>Public constructor with <code>&#64;ConstructorParameters</code> annotation:

        <blockquote>
          <pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public String getName() {return name;}
    <b>&#64;ConstructorParameters({"number", "name"})
    public NamedNumber(int number, String name)</b> {
        this.number = number;
        this.name = name;
    }
    private final int number;
    private final String name;
}
          </pre>
        </blockquote>
      </li>

      <li>Setter for every getter:

        <blockquote>
          <pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public void <b>setNumber</b>(int number) {this.number = number;}
    public String getName() {return name;}
    public void <b>setName</b>(String name) {this.name = name;}
    <b>public NamedNumber()</b> {}
    private int number;
    private String name;
}
          </pre>
        </blockquote>
      </li>

      <li>Interface with only getters:

        <blockquote>
          <pre>
public interface NamedNumber {
    public int getNumber();
    public String getName();
}
          </pre>
        </blockquote>
      </li>
    </ol>

    <p>It is usually better for classes that simply represent a
      collection of data to be <em>immutable</em>.  An instance of an
      immutable class cannot be changed after it has been constructed.
      Notice that <code>CompositeData</code> itself is immutable.
      Immutability has many advantages, notably with regard to
      thread-safety and security.  So the approach using setters should
      generally be avoided if possible.</p>


    <h3>Recursive types</h3>

    <p>Recursive (self-referential) types cannot be used in MXBean
      interfaces.  This is a consequence of the immutability of <a href="openmbean/CompositeType.html" title="class in javax.management.openmbean"><code>CompositeType</code></a>.  For example, the following type could not be the
      type of an attribute, because it refers to itself:</p>

    <pre>
public interface <b>Node</b> {
    public String getName();
    public int getPriority();
    public <b>Node</b> getNext();
}
</pre>

    <p>It is always possible to rewrite recursive types like this so
      they are no longer recursive.  Doing so may require introducing
      new types.  For example:</p>

    <pre>
public interface <b>NodeList</b> {
    public List&lt;Node&gt; getNodes();
}

public interface Node {
    public String getName();
    public int getPriority();
}
</pre>

    <h3>MBeanInfo contents for an MXBean</h3>

    <p>An MXBean is a type of Open MBean.  However, for compatibility
      reasons, its <a href="MBeanInfo.html" title="class in javax.management"><code>MBeanInfo</code></a> is not an <a href="openmbean/OpenMBeanInfo.html" title="interface in javax.management.openmbean"><code>OpenMBeanInfo</code></a>.
      In particular, when the type of an attribute, parameter, or
      operation return value is a primitive type such as <code>int</code>,
      or is <code>void</code> (for a return type), then the attribute,
      parameter, or operation will be represented respectively by an
      <a href="MBeanAttributeInfo.html" title="class in javax.management"><code>MBeanAttributeInfo</code></a>, <a href="MBeanParameterInfo.html" title="class in javax.management"><code>MBeanParameterInfo</code></a>, or
      <a href="MBeanOperationInfo.html" title="class in javax.management"><code>MBeanOperationInfo</code></a> whose <code>getType()</code> or <code>
      getReturnType()</code> returns the primitive name ("<code>int</code>" etc).
      This is so even though the mapping rules above specify that the
      <em>opendata</em> mapping is the wrapped type (<code>Integer</code>
      etc).</p>

    <p>The array of public constructors returned by <a href="MBeanInfo.html#getConstructors()"><code>MBeanInfo.getConstructors()</code></a> for an MXBean that is directly
      registered in the MBean Server will contain all of the public
      constructors of that MXBean.  If the class of the MXBean is not
      public then its constructors are not considered public either.
      The list returned for an MXBean that is constructed using the
      <a href="StandardMBean.html" title="class in javax.management"><code>StandardMBean</code></a> class is derived in the same way as for
      Standard MBeans.  Regardless of how the MXBean was constructed,
      its constructor parameters are not subject to MXBean mapping
      rules and do not have a corresponding <code>OpenType</code>.</p>

    <p>The array of notification types returned by <a href="MBeanInfo.html#getNotifications()"><code>MBeanInfo.getNotifications()</code></a> for an MXBean that is directly
      registered in the MBean Server will be empty if the MXBean does
      not implement the <a href="NotificationBroadcaster.html" title="interface in javax.management"><code>NotificationBroadcaster</code></a> interface.
      Otherwise, it will be the result of calling <a href="NotificationBroadcaster.html#getNotificationInfo()"><code>NotificationBroadcaster.getNotificationInfo()</code></a> at the time the MXBean
      was registered.  Even if the result of this method changes
      subsequently, the result of <code>MBeanInfo.getNotifications()</code>
      will not.  The list returned for an MXBean that is constructed
      using the <a href="StandardMBean.html" title="class in javax.management"><code>StandardMBean</code></a> or <a href="StandardEmitterMBean.html" title="class in javax.management"><code>StandardEmitterMBean</code></a>
      class is derived in the same way as for Standard MBeans.</p>

    <p>The <a href="Descriptor.html" title="interface in javax.management"><code>Descriptor</code></a> for all of the
      <code>MBeanAttributeInfo</code>, <code>MBeanParameterInfo</code>, and
      <code>MBeanOperationInfo</code> objects contained in the <code>MBeanInfo</code>
      will have a field <code>openType</code> whose value is the <a href="openmbean/OpenType.html" title="class in javax.management.openmbean"><code>OpenType</code></a>
      specified by the mapping rules above.  So even when <code>getType()</code>
      is "<code>int</code>", <code>getDescriptor().getField("openType")</code> will
      be <a href="openmbean/SimpleType.html#INTEGER"><code>SimpleType.INTEGER</code></a>.</p>

    <p>The <code>Descriptor</code> for each of these objects will also have a
      field <code>originalType</code> that is a string representing the Java type
      that appeared in the MXBean interface.  The format of this string
      is described in the section <a href="#type-names">Type Names</a>
      below.</p>

    <p>The <code>Descriptor</code> for the <code>MBeanInfo</code> will have a field
      <code>mxbean</code> whose value is the string "<code>true</code>".</p>


    <h3 id="type-names">Type Names</h3>

    <p>Sometimes the unmapped type <em>T</em> of a method parameter or
    return value in an MXBean must be represented as a string.  If
    <em>T</em> is a non-generic type, this string is the value
    returned by <a href="../../../java.base/java/lang/Class.html#getName()"><code>Class.getName()</code></a>.  Otherwise it is the value of
    <em>genericstring(T)</em>, defined as follows:

    <ul>

      <li>If <em>T</em> is a non-generic non-array type,
      <em>genericstring(T)</em> is the value returned by <a href="../../../java.base/java/lang/Class.html#getName()"><code>Class.getName()</code></a>, for example <code>"int"</code> or <code>
      "java.lang.String"</code>.

      <li>If <em>T</em> is an array <em>E[]</em>,
      <em>genericstring(T)</em> is <em>genericstring(E)</em> followed
      by <code>"[]"</code>.  For example, <em>genericstring(<code>int[]</code>)</em>
      is <code>"int[]"</code>, and <em>genericstring(<code>
      List&lt;String&gt;[][]</code>)</em> is <code>
      "java.util.List&lt;java.lang.String&gt;[][]"</code>.

    <li>Otherwise, <em>T</em> is a parameterized type such as <code>
    List&lt;String&gt;</code> and <em>genericstring(T)</em> consists of the
    following: the fully-qualified name of the parameterized type as
    returned by <code>Class.getName()</code>; a left angle bracket (<code>
    "&lt;"</code>); <em>genericstring(A)</em> where <em>A</em> is the first
    type parameter; if there is a second type parameter <em>B</em>
    then <code>", "</code> (a comma and a single space) followed by
    <em>genericstring(B)</em>; a right angle bracket (<code>"&gt;"</code>).

    </ul>

    <p>Note that if a method returns <code>int[]</code>, this will be
      represented by the string <code>"[I"</code> returned by <code>
      Class.getName()</code>, but if a method returns <code>List&lt;int[]&gt;</code>,
      this will be represented by the string <code>
      "java.util.List&lt;int[]&gt;"</code>.

    <h3>Exceptions</h3>

    <p>A problem with mapping <em>from</em> Java types <em>to</em>
      Open types is signaled with an <a href="openmbean/OpenDataException.html" title="class in javax.management.openmbean"><code>OpenDataException</code></a>.  This
      can happen when an MXBean interface is being analyzed, for
      example if it references a type like <a href="../../../java.base/java/util/Random.html" title="class in java.util"><code>java.util.Random</code></a> that has no getters.  Or it can happen when an
      instance is being converted (a return value from a method in an
      MXBean or a parameter to a method in an MXBean proxy), for
      example when converting from <code>SortedSet&lt;String&gt;</code> to <code>
      String[]</code> if the <code>SortedSet</code> has a non-null <code>
      Comparator</code>.</p>

    <p>A problem with mapping <em>to</em> Java types <em>from</em>
      Open types is signaled with an <a href="../../../java.base/java/io/InvalidObjectException.html" title="class in java.io"><code>InvalidObjectException</code></a>.
      This can happen when an MXBean interface is being analyzed, for
      example if it references a type that is not
      <em>reconstructible</em> according to the rules above, in a
      context where a reconstructible type is required.  Or it can
      happen when an instance is being converted (a parameter to a
      method in an MXBean or a return value from a method in an MXBean
      proxy), for example from a String to an Enum if there is no Enum
      constant with that name.</p>

    <p>Depending on the context, the <code>OpenDataException</code> or
      <code>InvalidObjectException</code> may be wrapped in another
      exception such as <a href="RuntimeMBeanException.html" title="class in javax.management"><code>RuntimeMBeanException</code></a> or <a href="../../../java.base/java/lang/reflect/UndeclaredThrowableException.html" title="class in java.lang.reflect"><code>UndeclaredThrowableException</code></a>.  For every thrown exception,
      the condition <em>C</em> will be true: "<em>e</em> is <code>
      OpenDataException</code> or <code>InvalidObjectException</code> (as
      appropriate), or <em>C</em> is true of <em>e</em>.<a href="../../../java.base/java/lang/Throwable.html#getCause()"><code>getCause()</code></a>".</p></div>
<dl class="notes">
<dt>Since:</dt>
<dd>1.6</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== ANNOTATION INTERFACE OPTIONAL MEMBER SUMMARY =========== -->
<li>
<section class="member-summary" id="annotation-interface-optional-element-summary">
<h2>Optional Element Summary</h2>
<div class="caption"><span>Optional Elements</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Optional Element</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>boolean</code></div>
<div class="col-second even-row-color"><code><a href="#value()" class="member-name-link">value</a></code></div>
<div class="col-last even-row-color">
<div class="block">True if the annotated interface is an MXBean interface.</div>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details" id="annotation-interface-element-detail">
<ul class="details-list">
<!-- ============ ANNOTATION INTERFACE MEMBER DETAIL =========== -->
<li>
<section class="member-details">
<h2>Element Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="value()">
<h3>value</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">value</span></div>
<div class="block">True if the annotated interface is an MXBean interface.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>true if the annotated interface is an MXBean interface.</dd>
</dl>
<dl class="notes">
<dt>Default:</dt>
<dd>true</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small><a href="https://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="https://docs.oracle.com/pls/topic/lookup?ctx=javase17&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples. <a href="https://docs.oracle.com/en/java/javase/index.html">Other versions.</a><br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../legal/copyright.html">Copyright</a> &copy; 1993, 2023, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="https://www.oracle.com/java/javase/terms/license/java17speclicense.html">license terms</a> and the <a href="https://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. <br><strong>DRAFT 17-crac+4-17</strong> <!-- Version 17-crac+4-17 --></small></p>
</footer>
</div>
</div>
</body>
</html>
